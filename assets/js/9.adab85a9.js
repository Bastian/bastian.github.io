(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{395:function(t,e,s){"use strict";s.r(e);var n=s(43),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"bot-lifecycle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bot-lifecycle"}},[t._v("#")]),t._v(" Bot Lifecycle")]),t._v(" "),s("p",[t._v("It's important to know the life-cycle of a discord bot to properly handle disconnects.\nThe following state diagram shows the 4 states a bot can have:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://javacord.org/img/tutorials/bot-life-cycle/state-diagram.svg",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"the-four-states"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#the-four-states"}},[t._v("#")]),t._v(" 4️⃣ The four states")]),t._v(" "),s("h3",{attrs:{id:"connected"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#connected"}},[t._v("#")]),t._v(" Connected")]),t._v(" "),s("p",[t._v("The bot is connected to the websocket and receives all events.")]),t._v(" "),s("h3",{attrs:{id:"disconnected"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#disconnected"}},[t._v("#")]),t._v(" Disconnected")]),t._v(" "),s("p",[t._v("The bot is not connected to the websocket and receives no events. It's not uncommon for a bot to occasionally lose connection.\nThis can have various reasons, for example:")]),t._v(" "),s("ul",[s("li",[t._v("Your bot lost its internet connection")]),t._v(" "),s("li",[t._v("Discord restarted the gateway server you are currently connected to")]),t._v(" "),s("li",[t._v("A plane crashed into Discord's data center")])]),t._v(" "),s("p",[t._v("The bot will periodically try ro resume/reconnect to the websocket. It will start with a small frequency and increase it\nwith every failed reconnect attempt. You can modify this reconnect delay with the "),s("code",[t._v("DiscordApi#setReconnectDelay(...)")]),t._v(" method.\nThe following example code would increase the delay linearly.\nThe 1st attempt would be delayed for "),s("code",[t._v("2")]),t._v(" seconds, the 2nd attempt for "),s("code",[t._v("4")]),t._v(" seconds, the 3rd attempts for "),s("code",[t._v("6")]),t._v(" seconds, ...")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("api"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setReconnectDelay")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("attempt "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" attempt "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("blockquote",[s("p",[s("strong",[t._v("Important:")]),t._v(" Bots can only reconnect 1000 times in a 24-hour period (every ~90 seconds). This limit is global and across all shards.\nUpon hitting this limit, all active sessions for the bot will be terminated, the bot's token will be reset, and\nyou will receive an email notification. This is the reason Javacord increases the reconnect delay with every attempt.")])]),t._v(" "),s("p",[t._v("By default, the following formula is used to calculate the reconnect delay:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://javacord.org/img/tutorials/bot-life-cycle/reconnect-delay.png",alt:""}})]),t._v(" "),s("p",[t._v("For shard "),s("code",[t._v("0")]),t._v(", the delays will look like this:")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("Attempt")]),t._v(" "),s("th",[t._v("Delay")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("1")]),t._v(" "),s("td",[t._v("1")])]),t._v(" "),s("tr",[s("td",[t._v("2")]),t._v(" "),s("td",[t._v("2")])]),t._v(" "),s("tr",[s("td",[t._v("3")]),t._v(" "),s("td",[t._v("4")])]),t._v(" "),s("tr",[s("td",[t._v("4")]),t._v(" "),s("td",[t._v("6")])]),t._v(" "),s("tr",[s("td",[t._v("5")]),t._v(" "),s("td",[t._v("7")])]),t._v(" "),s("tr",[s("td",[t._v("...")]),t._v(" "),s("td",[t._v("...")])]),t._v(" "),s("tr",[s("td",[t._v("10")]),t._v(" "),s("td",[t._v("16")])]),t._v(" "),s("tr",[s("td",[t._v("15")]),t._v(" "),s("td",[t._v("23")])]),t._v(" "),s("tr",[s("td",[t._v("20")]),t._v(" "),s("td",[t._v("30")])]),t._v(" "),s("tr",[s("td",[t._v("...")]),t._v(" "),s("td",[t._v("...")])]),t._v(" "),s("tr",[s("td",[t._v("50")]),t._v(" "),s("td",[t._v("59")])]),t._v(" "),s("tr",[s("td",[t._v("100")]),t._v(" "),s("td",[t._v("91")])]),t._v(" "),s("tr",[s("td",[t._v("150")]),t._v(" "),s("td",[t._v("115")])]),t._v(" "),s("tr",[s("td",[t._v("...")]),t._v(" "),s("td",[t._v("...")])])])]),t._v(" "),s("h3",{attrs:{id:"resuming"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resuming"}},[t._v("#")]),t._v(" Resuming")]),t._v(" "),s("p",[t._v("Resuming is only possible for a short time after being disconnected. If the bot can successfully resume the connection,\nyou will not miss any events. Your bot will receive all events you missed while being disconnected. The cache gets updated\naccordingly.")]),t._v(" "),s("h3",{attrs:{id:"reconnecting"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reconnecting"}},[t._v("#")]),t._v(" Reconnecting")]),t._v(" "),s("p",[t._v("If your bot reconnects (not resumes!), the whole cache gets wiped and you will not receive any missed events.")]),t._v(" "),s("p",[s("strong",[t._v("What does this mean?")])]),t._v(" "),s("ul",[s("li",[t._v("References to entities (e.g. a "),s("code",[t._v("Server")]),t._v(", "),s("code",[t._v("User")]),t._v(", "),s("code",[t._v("Channel")]),t._v(", ...) will be outdated. This is why you should never store\nentities, but the id instead. See "),s("a",{attrs:{href:"http://localhost:4000/wiki/advanced-tutorials/entity-cache/#how-long-are-cached-entities-valid",target:"_blank",rel:"noopener noreferrer"}},[t._v("Entity Cache"),s("OutboundLink")],1),t._v(".")]),t._v(" "),s("li",[t._v("You will miss events. There's no way to receive the missed events.")]),t._v(" "),s("li",[t._v("Listeners attached to entities will "),s("strong",[t._v("not")]),t._v(" be affected, because they are bound to the entity's id, not the object itself.")])]),t._v(" "),s("h2",{attrs:{id:"how-to-handle-disconnects"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#how-to-handle-disconnects"}},[t._v("#")]),t._v(" 🔁 How to handle disconnects")]),t._v(" "),s("p",[t._v("For most bots, there's nothing you have to do. All registered listeners are reconnect-resistant, which means if your bot\nis only reacting to events, it will work fine after a restart. For example, the following code will not be affected by a\nreconnect (besides maybe some missed "),s("code",[t._v("!ping")]),t._v(" messages):")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("api"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addMessageCreateListener")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("event "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getMessage")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getContent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("equalsIgnoreCase")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"!ping"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        event"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getChannel")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sendMessage")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Pong!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("In case you want to handle reconnects (e.g. fetch the message history to detect missed messages), there are\nspecial connection-related listeners which can be used to track the state of the bot:")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("LostConnectionListener")])]),t._v(" "),s("li",[s("code",[t._v("ReconnectListener")])]),t._v(" "),s("li",[s("code",[t._v("ResumeListener")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);